// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"

  // Pooled (runtime, edge/serverless friendly)
  url       = env("DATABASE_URL")

  // Non-pooled (required for prisma migrate deploy)
  directUrl = env("DIRECT_DATABASE_URL")
}

model ContactMessage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name      String?
  email     String?
  subject   String?
  message   String

  honeypot  String?
  ip        String?
  userAgent String?
}

/* ---------------------------------------------
   VANTERA - Coverage + Listings (Foundation)
   JamesEdition-style: Cities + Region Clusters
---------------------------------------------- */

enum CoverageTier {
  TIER_0
  TIER_1
  TIER_2
  TIER_3
}

enum CoverageStatus {
  LIVE
  TRACKING
  EXPANDING
}

enum ListingStatus {
  DRAFT
  LIVE
  SOLD
  ARCHIVED
}

enum ListingVisibility {
  PUBLIC
  PRIVATE
}

enum VerificationLevel {
  SELF_REPORTED
  VERIFIED_DOCS
  VERIFIED_ON_SITE
}

enum ImportRunStatus {
  RUNNING
  SUCCEEDED
  FAILED
}

/**
 * RegionCluster
 * Ex: "Costa del Sol", "French Riviera", "Miami Metro"
 */
model RegionCluster {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name      String
  slug      String   @unique

  // For ordering in UI
  tier      CoverageTier   @default(TIER_3)
  status    CoverageStatus @default(EXPANDING)
  priority  Int            @default(0)

  // Optional copy
  headline  String?
  blurb     String?

  // For map/seo pages later
  country   String?
  region    String?

  cities    City[]

  @@index([tier, priority])
}

/**
 * City
 * Canonical city object, linked optionally to a RegionCluster
 */
model City {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name      String
  slug      String   @unique

  country   String
  region    String?
  tz        String

  tier      CoverageTier   @default(TIER_3)
  status    CoverageStatus @default(EXPANDING)
  priority  Int            @default(0)

  // Optional hero / card image
  heroImageSrc String?
  heroImageAlt String?

  // Optional editorial copy
  blurb     String?

  // Optional geo (helpful for maps later)
  lat       Float?
  lng       Float?

  clusterId String?
  cluster   RegionCluster? @relation(fields: [clusterId], references: [id], onDelete: SetNull)

  metrics   CityMetric[]
  listings  Listing[]

  @@index([country])
  @@index([tier, priority])
  @@index([clusterId])
}

/**
 * CityMetric
 * Snapshot series for city-level market signals.
 * Use this to power "Vantera Market Index" per city.
 */
model CityMetric {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  cityId    String
  city      City     @relation(fields: [cityId], references: [id], onDelete: Cascade)

  // Snapshot date (for monthly series)
  asOf      DateTime

  // Core signals (nullable until you have source)
  medianPricePerSqm  Int?
  primePricePerSqm   Int?
  medianRentPerSqm   Int?
  yoyPriceChangePct  Float?
  yoyRentChangePct   Float?
  daysOnMarketMedian Int?
  activeListingCount Int?

  // Confidence and provenance
  confidenceScore Int?    // 0-100
  sourceNote      String? // "manual", "licensed feed", etc.

  @@unique([cityId, asOf])
  @@index([cityId, asOf])
}

/**
 * ImportRun
 * Tracks ingestion jobs for dashboards, audit, and debugging.
 */
model ImportRun {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // "attom"
  source    String

  // "cities" | "properties"
  scope     String

  // Optional scoping for dashboards
  region    String?
  market    String?

  // Params used for the run (radius, limit, filters, etc.)
  params    Json

  // Status tracking
  status    ImportRunStatus @default(RUNNING)

  startedAt DateTime @default(now())
  finishedAt DateTime?

  // Counts
  scanned   Int      @default(0)
  created   Int      @default(0)
  skipped   Int      @default(0)
  errors    Int      @default(0)

  // Small sample of errors for quick debugging
  errorSamples Json?

  message   String?

  @@index([source, scope, createdAt])
  @@index([status, createdAt])
}

/**
 * Listing
 * Luxury-first listing model.
 */
model Listing {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  slug      String   @unique

  // Provider identity (critical for ingestion + dedupe)
  source          String   @default("manual")
  sourceId        String?
  sourceUrl       String?
  sourceUpdatedAt DateTime?

  cityId    String
  city      City     @relation(fields: [cityId], references: [id], onDelete: Cascade)

  status       ListingStatus     @default(DRAFT)
  visibility   ListingVisibility @default(PUBLIC)
  verification VerificationLevel @default(SELF_REPORTED)

  // Display
  title        String
  headline     String?
  description  String?

  // Location
  neighborhood  String?
  address       String?
  addressHidden Boolean @default(false)

  lat           Float?
  lng           Float?

  // Core specs
  propertyType String?
  bedrooms     Int?
  bathrooms    Int?

  // Canonical metric fields (m²)
  builtM2      Int?
  plotM2       Int?

  // Source-native size fields (sqft for ATTOM)
  builtSqft    Int?
  plotSqft     Int?

  // Pricing
  price        Int?
  currency     String  @default("EUR")

  // Confidence flags (0-100)
  priceConfidence  Int?
  dataCompleteness Int?

  // Running costs
  communityFeesMonthly Int?
  ibiYearly            Int?
  garbageTaxYearly     Int?

  // Truth fields (expand later)
  yearBuilt      Int?
  renovationYear Int?
  energyRating   String?

  // Media
  media        ListingMedia[] @relation("ListingMedia")

  // Cover media (optional 1:1)
  coverMediaId  String? @unique
  coverMedia    ListingMedia? @relation("ListingCover", fields: [coverMediaId], references: [id], onDelete: SetNull)

  // ✅ IMPORTANT FIX:
  // Postgres UNIQUE treats NULLs as distinct, but Prisma will still enforce the constraint.
  // This keeps ATTOM dedupe strong when sourceId exists, while allowing manual listings with null sourceId.
  @@unique([source, sourceId])

  @@index([cityId, status])
  @@index([status, visibility])
  @@index([cityId, price])
  @@index([source])
  @@index([priceConfidence])
  @@index([dataCompleteness])
}

/**
 * ListingMedia
 * Images first. Video later.
 */
model ListingMedia {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Main media -> listing relation (named to avoid ambiguity with "ListingCover")
  listingId String
  listing   Listing  @relation("ListingMedia", fields: [listingId], references: [id], onDelete: Cascade)

  // Image URL and metadata
  url       String
  alt       String?
  width     Int?
  height    Int?

  // Ordering for galleries
  sortOrder Int @default(0)

  // Optional type for future: image, floorplan, video
  kind      String @default("image")

  // Reverse relation for coverMedia
  coverOf   Listing? @relation("ListingCover")

  @@index([listingId, sortOrder])

  // (Optional) If you want hard dedupe for the same image URL per listing, uncomment:
  // @@unique([listingId, url])
}
